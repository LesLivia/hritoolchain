<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_2.dtd'>
<nta>
	<declaration>/**
*** CHANNELS
**/
// Human Channels
broadcast chan pass_out;
broadcast chan free_start;
broadcast chan free_stop;
broadcast chan start_h_action[int];
broadcast chan stop_h_action;

// Robot Controller Channels
broadcast chan start_recharging[int];
broadcast chan stop_recharging;
broadcast chan start_r_action[int];
broadcast chan stop_r_action;

// Battery Channels
broadcast chan dead_battery;
urgent broadcast chan full_battery;

/**
*** CONSTANTS
**/
double pi = 3.1415926535;

// Human Fatigue Profiles [fatiguing rate, recovery rate]
// MET = ln(1-epsilon)/(-lambda)
double young_healthy[2] = {0.005, 0.005}; // approx. 1380s
double young_sick[2] = {0.01, 0.004}; // approx. 690s
double elder_healthy[2] = {0.008, 0.0035}; // approx. 860s
double elder_sick[2] = {0.02, 0.001}; // approx. 350s 
double covid_patient[2] = {0.025, 0.001}; // approx. 280s

// Human Free Will Profiles
int childlike = 90;
int grownup = 99;
int whatever = 101;


/**
*** VARIABLES
**/

// Mission Mgmt
bool fail = false;
bool success = false;
bool served[#NHUMS#] = #NFALSE#;
// 0: human follower, 1: human leader, 2: human recipient
int patterns[#NHUMS#] = #PATTERNS#;
//
bool objectTaken[#NHUMS#] = #NFALSE#;
#HDESTINATIONS#

// Robot Mgmt
int currR = 1;

// Human Mgmt
int currH = 1;
int hExe = 0;

// Sensor Outputs
double batteryCharge;
double robPositionX;
double robPositionY;

double humanFatigue[#NHUMS#] = #NZEROES#;
double humanPositionX[#NHUMS#] = #NZEROES#;
double humanPositionY[#NHUMS#] = #NZEROES#;
double humTheta[#NHUMS#] = #NZEROES#;

// Robot direction Control
double robTheta = 0.0;
bool robTurned = true;

/**
*** FLOOR PLAN
**/
typedef double point[2];
bool isInRectangle(point start, double dX, double dY, double length, double height) {
    bool destXisIn, destYisIn;
    if(fabs(length)&gt;fabs(height)) {
        if(length&gt;0) {
            destXisIn = dX &lt; start[0] + 0.95 * length &amp;&amp; dX &gt; start[0] - 0.05 * length;
        } else {
            destXisIn = dX &lt; start[0] + 0.05 * -length &amp;&amp; dX &gt; start[0] - 0.95 * -length;
        }
        destYisIn = dY &lt; start[1] + height / 2 &amp;&amp; dY &gt; start[1] - height / 2;
    } else {
        destXisIn = dX &lt; start[0] + length/2 &amp;&amp; dX &gt; start[0] - length/2;
        if(height&gt;0) {
            destYisIn = dY &lt; start[1] + 0.95*height &amp;&amp; dY &gt; start[1] - 0.005*height;
        } else {
            destYisIn = dY &lt; start[1] + 0.005*-height &amp;&amp; dY &gt; start[1] - 0.95*-height;
        }
    }
    return destXisIn &amp;&amp; destYisIn;
}

double calculateDistance() {
    double xdifference = pow(robPositionX-humanPositionX[currH-1], 2);
    double ydifference = pow(robPositionY-humanPositionY[currH-1], 2);
    double distance = sqrt(xdifference + ydifference)/100;
    if(distance&lt;0) {
        return -distance;
    } else {
        return distance;
    }
}

// Wall Corner Points
#FLOORPLAN#
</declaration>
    <template>
        <name>Human_Follower</name>
        <parameter>int id, int v, int p_f, int p_fw </parameter>
        <declaration>clock h, t, F, Fp;
clock updateTimer;
clock freeWill;

double lambda, mi;
double MET = 60.0;
double passout_th = 1.0;

// Free Will Model
int obey;
int disobey;
int freeWillRange = 100;
int freeWillTh = 101;

// Fatigue Sharing Parameters
int pollTime = 2;
//double oldFatigue;

// Position Sharing Parameters
int timeP = 0;
//bool changeDir = false;
bool recovered = true;
double oldPosX;
double oldPosY;

void updateF(double coeff, bool walking) {  
    if(walking) {
        humanFatigue[id-1] = 1-(1-humanFatigue[id-1])*exp(coeff*pollTime); 
    } else {
        humanFatigue[id-1] = humanFatigue[id-1]*exp(coeff*pollTime);
    }

    humanFatigue[id-1] = fmax(0, humanFatigue[id-1]);
}

bool destIsOnTheLeft, destIsOnTheRight, destIsAhead, destIsBehind;
double allowanceFactor = 0.95;
void changeDirection() {
    double inverseValue, turnLeft, turnRight, length=2000.0, height=100.0;
    double toCheck, humThF, humThB;   
    point pos = {humanPositionX[id-1], humanPositionY[id-1]}, dest = {robPositionX, robPositionY};   
    destIsOnTheLeft = false; destIsOnTheRight = false; destIsAhead = false; destIsBehind = false;

    if(humTheta[id-1] == 0) {
        inverseValue = -pi; turnLeft = pi/2; turnRight = -pi/2;
        toCheck = humanPositionX[id-1];
        humThF = allowanceFactor*HALL2_4[0];
        humThB = HALL2_1[0]+(1-allowanceFactor)*HALL2_1[0];
        destIsOnTheLeft = isInRectangle(pos, dest[0], dest[1], height, length);
        destIsOnTheRight = isInRectangle(pos, dest[0], dest[1], height, -length);
        destIsAhead = isInRectangle(pos, dest[0], dest[1], length, height);
        destIsBehind = isInRectangle(pos, dest[0], dest[1], -length, height);
    } else if (humTheta[id-1] == -pi) {
        inverseValue = 0.0; turnLeft = -pi/2; turnRight = pi/2;
        toCheck = humanPositionX[id-1];
        humThF = allowanceFactor*HALL2_4[0];
        humThB = HALL2_1[0]+(1-allowanceFactor)*HALL2_1[0];
        destIsOnTheLeft = isInRectangle(pos, dest[0], dest[1], height, -length);
        destIsOnTheRight = isInRectangle(pos, dest[0], dest[1], height, length);
        destIsAhead = isInRectangle(pos, dest[0], dest[1], -length, height);
        destIsBehind = isInRectangle(pos, dest[0], dest[1], length, height);
    } else if (humTheta[id-1] == pi/2) {
        inverseValue = -pi/2; turnLeft = -pi; turnRight = 0;
        toCheck = humanPositionY[id-1];
        humThF = allowanceFactor*HALL1_4[1];
        humThB = HALL2_4[1]+(1-allowanceFactor);
        destIsOnTheLeft = isInRectangle(pos, dest[0], dest[1], -length, height);
        destIsOnTheRight = isInRectangle(pos, dest[0], dest[1], length, height);
        destIsAhead = isInRectangle(pos, dest[0], dest[1], height, length);
        destIsBehind = isInRectangle(pos, dest[0], dest[1], height, -length);
    } else if (humTheta[id-1] == -pi/2) {
        inverseValue = pi/2; turnLeft = 0; turnRight = -pi;      
        toCheck = humanPositionY[id-1];
        humThF = allowanceFactor*HALL1_4[1];
        humThB = HALL2_4[1]+(1-allowanceFactor);
        destIsOnTheLeft = isInRectangle(pos, dest[0], dest[1], length, height);
        destIsOnTheRight = isInRectangle(pos, dest[0], dest[1], -length, height);
        destIsAhead = isInRectangle(pos, dest[0], dest[1], height, -length);
        destIsBehind = isInRectangle(pos, dest[0], dest[1], height, length);
    }

    // should change direction if wall is close, 
    // or destination is not reachable with current direction
    if(recovered) {
        if(destIsAhead) {
            return;
        } else if(destIsBehind || toCheck &lt; humThB || toCheck &gt; humThF) { //should turn 180 deg
            humTheta[id-1] = inverseValue;
            timeP = 0;
            recovered = false;
            oldPosX = humanPositionX[id-1];
            oldPosY = humanPositionY[id-1];   
        } else if (destIsOnTheLeft) { //should turn left
            humTheta[id-1] = turnLeft;
            timeP = 0;
            oldPosX = humanPositionX[id-1];
            oldPosY = humanPositionY[id-1];   
        } else if (destIsOnTheRight) { //should turn right
            humTheta[id-1] = turnRight;
            timeP = 0;
            oldPosX = humanPositionX[id-1];
            oldPosY = humanPositionY[id-1];   
        } 
    } else {
        recovered = toCheck &gt; humThB &amp;&amp; toCheck &lt; humThF;
    }
}

void updateP(double coeff) {
    double h;
    //!!!!!!!!!!! TODO: perchè senza currH &lt; 3 non funziona?
    if(coeff&gt;0 &amp;&amp; currH&lt;=3) {
        changeDirection();
        timeP += pollTime;
    }

    h = coeff*timeP;

    humanPositionX[id-1] = oldPosX + h*cos(humTheta[id-1]);
    humanPositionY[id-1] = oldPosY + h*sin(humTheta[id-1]);
}

void updateFreeWill(){
    if(currH==id) {
        obey = 99;
        disobey = 1;
    } else {
        obey = 100;
        disobey = 1;
        freeWill = 0;
        freeWillRange = 10;
        freeWillTh = 20;
    }
}

void initHuman() {
    F = 0; 
    Fp = 0;
    t = 0;
    h = 0;
    
    updateTimer = 0;
    humanPositionX[id-1] = HALL1_1[0]+20;
    humanPositionY[id-1] = HALL2_1[1] + (HALL1_1[1]-HALL2_1[1])/2 + 25;
    oldPosX = humanPositionX[id-1];
    oldPosY = humanPositionY[id-1];

    obey = 99;
    disobey = 1;

    // unfortunately the switch case is not supported yet
    if(p_f==1) {
        lambda = young_healthy[0]; mi = young_healthy[1];
    } else if(p_f==2) {
        lambda = young_sick[0]; mi = young_sick[1];
    } else if(p_f==3) {
        lambda = elder_healthy[0]; mi = elder_healthy[1];
    } else if(p_f==4) {
        lambda = elder_sick[0]; mi = elder_sick[1];
    } else if(p_f==5) {
        lambda = covid_patient[0]; mi = covid_patient[1];
    } else {
        lambda = 0.005; mi = 0.005; //default values
    }

    if(p_fw==1) {
       freeWillTh = grownup;
    } else if(p_fw == 2) {
       freeWillTh = childlike;
    } else if(p_fw == 3) {
       freeWillTh = whatever;
    }

}</declaration>
        <location id="id0" x="-399" y="-297">
            <name x="-433" y="-323">idle</name>
            <label kind="invariant" x="-518" y="-442">t' == 1 
&amp;&amp; h' == 0 
&amp;&amp; freeWill'==0 
&amp;&amp; Fp'==0 
&amp;&amp; F' == -Fp*mi*exp(-mi*t)
&amp;&amp; updateTimer
&lt;=pollTime</label>
        </location>
        <location id="id1" x="212" y="-297">
            <name x="204" y="-331">busy</name>
            <label kind="invariant" x="204" y="-450">t' == 1 
&amp;&amp; h'  == v
&amp;&amp; freeWill'==0 
&amp;&amp; Fp'==0
&amp;&amp; F &lt;= passout_th 
&amp;&amp; F' == Fp*lambda*exp(-lambda*t)
&amp;&amp; updateTimer&lt;=pollTime</label>
        </location>
        <location id="id2" x="-594" y="-296">
            <name x="-637" y="-313">Init</name>
            <committed/>
        </location>
        <location id="id3" x="365" y="-297">
            <name x="382" y="-314">passed_out</name>
            <label kind="invariant" x="382" y="-297">t' == 0 &amp;&amp;
F' == 0 &amp;&amp;
h' == 0 &amp;&amp;
freeWill' == 0</label>
            <label kind="exponentialrate" x="357" y="-280">1</label>
        </location>
        <location id="id4" x="-136" y="-399">
            <name x="-146" y="-433">c1</name>
            <urgent/>
        </location>
        <location id="id5" x="34" y="-153">
            <name x="42" y="-187">c3</name>
            <urgent/>
        </location>
        <location id="id6" x="51" y="-399">
            <name x="41" y="-433">c2</name>
            <urgent/>
        </location>
        <branchpoint id="id7" x="-25" y="-153">
        </branchpoint>
        <branchpoint id="id8" x="-85" y="-399">
        </branchpoint>
        <init ref="id2"/>
        <transition>
            <source ref="id0"/>
            <target ref="id6"/>
            <label kind="guard" x="-280" y="-493">!served[id-1]
&amp;&amp; freeWill&gt;=freeWillTh</label>
            <label kind="synchronisation" x="-272" y="-459">free_start!</label>
            <label kind="assignment" x="-102" y="-484">t = 0, updateTimer=0,
freeWill = 0</label>
            <nail x="-272" y="-442"/>
            <nail x="0" y="-442"/>
        </transition>
        <transition>
            <source ref="id6"/>
            <target ref="id1"/>
            <label kind="guard" x="8" y="-331">F==0</label>
            <label kind="assignment" x="8" y="-314">Fp=1</label>
            <nail x="51" y="-297"/>
        </transition>
        <transition>
            <source ref="id6"/>
            <target ref="id1"/>
            <label kind="guard" x="68" y="-399">F&gt;0</label>
            <label kind="assignment" x="59" y="-382">Fp=1-F</label>
            <nail x="119" y="-399"/>
        </transition>
        <transition>
            <source ref="id8"/>
            <target ref="id6"/>
            <label kind="assignment" x="-68" y="-399">t = 0, 
updateTimer=0</label>
            <label kind="probability" x="-68" y="-416">obey</label>
        </transition>
        <transition>
            <source ref="id1"/>
            <target ref="id0"/>
            <label kind="guard" x="-306" y="-119">!served[id-1] &amp;&amp;
freeWill&gt;=freeWillTh</label>
            <label kind="synchronisation" x="-306" y="-85">free_stop!</label>
            <label kind="assignment" x="-102" y="-119">t = 0, freeWill = 0, timeP = 0, Fp = F, 
oldPosX=humanPositionX[id-1],
oldPosY=humanPositionY[id-1],
updateTimer=0,
updateFreeWill()</label>
            <nail x="110" y="-127"/>
            <nail x="-314" y="-127"/>
        </transition>
        <transition>
            <source ref="id7"/>
            <target ref="id1"/>
            <label kind="probability" x="-25" y="-229">disobey</label>
            <nail x="-25" y="-212"/>
            <nail x="161" y="-212"/>
        </transition>
        <transition>
            <source ref="id7"/>
            <target ref="id0"/>
            <label kind="assignment" x="-255" y="-306">timeP = 0, t = 0, Fp=F, 
oldPosX=humanPositionX[id-1],
oldPosY=humanPositionY[id-1],
updateTimer=0,
updateFreeWill()</label>
            <label kind="probability" x="-297" y="-238">obey</label>
            <nail x="-68" y="-212"/>
            <nail x="-331" y="-212"/>
        </transition>
        <transition>
            <source ref="id5"/>
            <target ref="id7"/>
        </transition>
        <transition>
            <source ref="id1"/>
            <target ref="id5"/>
            <label kind="synchronisation" x="42" y="-229">stop_h_action?</label>
            <nail x="161" y="-212"/>
            <nail x="34" y="-212"/>
        </transition>
        <transition>
            <source ref="id0"/>
            <target ref="id4"/>
            <label kind="synchronisation" x="-280" y="-416">start_h_action[id]?</label>
            <nail x="-272" y="-399"/>
        </transition>
        <transition>
            <source ref="id8"/>
            <target ref="id0"/>
            <label kind="probability" x="-153" y="-357">disobey</label>
            <nail x="-85" y="-365"/>
            <nail x="-272" y="-365"/>
        </transition>
        <transition>
            <source ref="id4"/>
            <target ref="id8"/>
        </transition>
        <transition>
            <source ref="id1"/>
            <target ref="id1"/>
            <label kind="guard" x="213" y="-195">updateTimer&gt;=pollTime</label>
            <label kind="assignment" x="213" y="-178">updateP(v),
updateF(-lambda, 1),
updateTimer=0,
freeWill = random(freeWillRange)</label>
            <nail x="213" y="-195"/>
            <nail x="264" y="-195"/>
        </transition>
        <transition>
            <source ref="id0"/>
            <target ref="id0"/>
            <label kind="guard" x="-568" y="-194">updateTimer&gt;=pollTime</label>
            <label kind="assignment" x="-569" y="-178">updateP(0),
updateF(-mi, 0),
updateTimer=0,
freeWill = random(freeWillRange)</label>
            <nail x="-398" y="-194"/>
            <nail x="-449" y="-194"/>
        </transition>
        <transition>
            <source ref="id1"/>
            <target ref="id3"/>
            <label kind="guard" x="230" y="-314">F &gt;= passout_th</label>
            <label kind="synchronisation" x="255" y="-297">pass_out!</label>
            <label kind="assignment" x="306" y="-280">t = 0</label>
        </transition>
        <transition>
            <source ref="id3"/>
            <target ref="id3"/>
            <nail x="340" y="-246"/>
            <nail x="382" y="-246"/>
        </transition>
        <transition>
            <source ref="id2"/>
            <target ref="id0"/>
            <label kind="assignment" x="-552" y="-289">initHuman()</label>
        </transition>
    </template>
    <template>
        <name>Human_Leader</name>
        <parameter>int id, int v, int p_f, int p_fw</parameter>
        <declaration>clock h, t, F, Fp;
clock updateTimer;
clock freeWill;

double lambda = 0.005, mi = 0.005;
double MET = 60.0;
double passout_th = 1.0;

//Free Will Model
double freeWillTh = 100.0;
double freeWillRange = 95.0;

// Fatigue Sharing Parameters
int pollTime = 1;

// Position Sharing Parameters
int timeP = 0;
bool changeDir = false;
bool recovered = true;
double oldPosX;
double oldPosY;

void updateF(double coeff, bool walking) {
    if(walking) {
        humanFatigue[id-1] = 1-(1-humanFatigue[id-1])*exp(coeff*pollTime); 
    } else {
        humanFatigue[id-1] = humanFatigue[id-1]*exp(coeff*pollTime);
    }

    humanFatigue[id-1] = fmax(0, humanFatigue[id-1]);
}

bool destIsOnTheLeft, destIsOnTheRight, destIsAhead, destIsBehind;
double allowanceFactor = 0.95;
void changeDirection() {
    double inverseValue, turnLeft, turnRight, length=2000.0, height=100.0;
    double toCheck, humThF, humThB;   
    point pos = {humanPositionX[id-1], humanPositionY[id-1]}, dest = {destX[currH-1], destY[currH-1]};   
    destIsOnTheLeft = false; destIsOnTheRight = false; destIsAhead = false; destIsBehind = false;

if(humTheta[id-1] == 0) {
        inverseValue = -pi; turnLeft = pi/2; turnRight = -pi/2;
        toCheck = humanPositionX[id-1];
        humThF = allowanceFactor*HALL2_4[0];
        humThB = HALL2_1[0]+(1-allowanceFactor)*HALL2_1[0];
        destIsOnTheLeft = isInRectangle(pos, dest[0], dest[1], height, length);
        destIsOnTheRight = isInRectangle(pos, dest[0], dest[1], height, -length);
        destIsAhead = isInRectangle(pos, dest[0], dest[1], length, height);
        destIsBehind = isInRectangle(pos, dest[0], dest[1], -length, height);
    } else if (humTheta[id-1] == -pi) {
        inverseValue = 0.0; turnLeft = -pi/2; turnRight = pi/2;
        toCheck = humanPositionX[id-1];
        humThF = allowanceFactor*HALL2_4[0];
        humThB = HALL2_1[0]+(1-allowanceFactor)*HALL2_1[0];
        destIsOnTheLeft = isInRectangle(pos, dest[0], dest[1], height, -length);
        destIsOnTheRight = isInRectangle(pos, dest[0], dest[1], height, length);
        destIsAhead = isInRectangle(pos, dest[0], dest[1], -length, height);
        destIsBehind = isInRectangle(pos, dest[0], dest[1], length, height);
    } else if (humTheta[id-1] == pi/2) {
        inverseValue = -pi/2; turnLeft = -pi; turnRight = 0;
        toCheck = humanPositionY[id-1];
        humThF = allowanceFactor*HALL1_4[1];
        humThB = HALL2_4[1]+(1-allowanceFactor);
        destIsOnTheLeft = isInRectangle(pos, dest[0], dest[1], -length, height);
        destIsOnTheRight = isInRectangle(pos, dest[0], dest[1], length, height);
        destIsAhead = isInRectangle(pos, dest[0], dest[1], height, length);
        destIsBehind = isInRectangle(pos, dest[0], dest[1], height, -length);
    } else if (humTheta[id-1] == -pi/2) {
        inverseValue = pi/2; turnLeft = 0; turnRight = -pi;      
        toCheck = humanPositionY[id-1];
        humThF = allowanceFactor*HALL1_4[1];
        humThB = HALL2_4[1]+(1-allowanceFactor);
        destIsOnTheLeft = isInRectangle(pos, dest[0], dest[1], length, height);
        destIsOnTheRight = isInRectangle(pos, dest[0], dest[1], -length, height);
        destIsAhead = isInRectangle(pos, dest[0], dest[1], height, -length);
        destIsBehind = isInRectangle(pos, dest[0], dest[1], height, length);
    }

    // should change direction if wall is close, 
    // or destination is not reachable with current direction
    if(recovered) {
        if(destIsAhead) {
            return;
        } else if(destIsBehind || toCheck &lt; humThB || toCheck &gt; humThF) { //should turn 180 deg
            humTheta[id-1] = inverseValue;
            timeP = 0;
            recovered = false;
            oldPosX = humanPositionX[id-1];
            oldPosY = humanPositionY[id-1];   
        } else if (destIsOnTheLeft) { //should turn left
            humTheta[id-1] = turnLeft;
            timeP = 0;
            oldPosX = humanPositionX[id-1];
            oldPosY = humanPositionY[id-1];   
        } else if (destIsOnTheRight) { //should turn right
            humTheta[id-1] = turnRight;
            timeP = 0;
            oldPosX = humanPositionX[id-1];
            oldPosY = humanPositionY[id-1];   
        } 
    } else {
        recovered = toCheck &gt; humThB &amp;&amp; toCheck &lt; humThF;
    }
}

void updateP(double coeff) {
    double h;
    if(coeff&gt;0) {
        changeDirection();
        timeP += pollTime;
    }

    h = coeff*timeP;

    humanPositionX[id-1] = oldPosX + h*cos(humTheta[id-1]);
    humanPositionY[id-1] = oldPosY + h*sin(humTheta[id-1]);
}

void checkSuccess() {
    bool hXinDestInterval = humanPositionX[id-1] &gt;= destX[id-1]-50.0 &amp;&amp; humanPositionX[id-1] &lt;= destX[id-1]+50.0;
    bool hYinDestInterval = humanPositionY[id-1] &gt;= destY[id-1]-50.0 &amp;&amp; humanPositionY[id-1] &lt;= destY[id-1]+50.0;
    double humanRobotDist = calculateDistance();
    // when humans reach their destination, they can set themselves as "served"
    if(hXinDestInterval &amp;&amp; hYinDestInterval &amp;&amp; humanRobotDist &lt; 2) {
        served[id-1] = true;
    }
}

void initHuman() {
    F = 0;
    Fp = 0; 
    t = 0;
    h = 0;
    
    updateTimer = 0;
    humanPositionX[id-1] = HALL1_1[0]+20;
    humanPositionY[id-1] = HALL2_1[1] + (HALL1_1[1]-HALL2_1[1])/2 + 25;
    oldPosX = humanPositionX[id-1];
    oldPosY = humanPositionY[id-1];

    if(p_f==1) {
        lambda = young_healthy[0]; mi = young_healthy[1];
    } else if(p_f==2) {
        lambda = young_sick[0]; mi = young_sick[1];
    } else if(p_f==3) {
        lambda = elder_healthy[0]; mi = elder_healthy[1];
    } else if(p_f==4) {
        lambda = elder_sick[0]; mi = elder_sick[1];
    } else if(p_f==5) {
        lambda = covid_patient[0]; mi = covid_patient[1];
    } else {
        lambda = 0.005; mi = 0.005; //default values
    }

    if(p_fw==1) {
        freeWillTh = grownup;
    } else if(p_fw == 2) {
        freeWillTh = childlike;
    } else if(p_fw == 3) {
        freeWillTh = whatever;
    }

}</declaration>
        <location id="id9" x="-357" y="-221">
            <name x="-391" y="-247">idle</name>
            <label kind="invariant" x="-450" y="-365">t' == 1 
&amp;&amp; h' == 0 
&amp;&amp; Fp' == 0
&amp;&amp; F' == -Fp*mi*exp(-mi*t)
&amp;&amp; freeWill' == 0
&amp;&amp; updateTimer
&lt;=pollTime</label>
        </location>
        <location id="id10" x="254" y="-221">
            <name x="246" y="-255">busy</name>
            <label kind="invariant" x="246" y="-374">t' == 1 
&amp;&amp; h'  == v 
&amp;&amp; Fp' == 0
&amp;&amp; F &lt;= passout_th 
&amp;&amp; freeWill' == 0 
&amp;&amp; F' == Fp*lambda*exp(-lambda*t)
&amp;&amp; updateTimer&lt;=pollTime</label>
        </location>
        <location id="id11" x="-552" y="-220">
            <name x="-595" y="-237">Init</name>
            <committed/>
        </location>
        <location id="id12" x="425" y="-221">
            <name x="442" y="-238">passed_out</name>
            <label kind="invariant" x="442" y="-221">t' == 0 &amp;&amp;
F' == 0 &amp;&amp;
h' == 0</label>
            <label kind="exponentialrate" x="417" y="-204">1</label>
        </location>
        <location id="id13" x="246" y="-42">
            <name x="229" y="-25">checking</name>
            <urgent/>
        </location>
        <location id="id14" x="-42" y="-272">
            <urgent/>
        </location>
        <init ref="id11"/>
        <transition>
            <source ref="id14"/>
            <target ref="id10"/>
            <label kind="guard" x="34" y="-238">Fp==0</label>
            <label kind="assignment" x="85" y="-238">Fp=1</label>
            <nail x="25" y="-221"/>
        </transition>
        <transition>
            <source ref="id14"/>
            <target ref="id10"/>
            <label kind="guard" x="-17" y="-289">F&gt;0</label>
            <label kind="assignment" x="17" y="-289">Fp=1-F</label>
            <nail x="144" y="-272"/>
        </transition>
        <transition>
            <source ref="id9"/>
            <target ref="id14"/>
            <label kind="guard" x="-229" y="-323">!served[id-1] 
&amp;&amp; currH == id</label>
            <label kind="synchronisation" x="-229" y="-289">start_h_action[id]!</label>
            <label kind="assignment" x="-229" y="-272">F = 0, t = 0, 
updateTimer=0, 
hExe = 1</label>
            <nail x="-238" y="-272"/>
        </transition>
        <transition>
            <source ref="id10"/>
            <target ref="id9"/>
            <label kind="guard" x="-272" y="-161">!served[id-1] &amp;&amp;
freeWill &gt;= freeWillTh</label>
            <label kind="synchronisation" x="-255" y="-178">stop_h_action!</label>
            <label kind="assignment" x="-119" y="-195">t = 0, hExe = 0, Fp=F,
oldPosX=humanPositionX[id-1],
oldPosY=humanPositionY[id-1],
updateTimer=0</label>
            <nail x="161" y="-161"/>
            <nail x="-263" y="-161"/>
        </transition>
        <transition>
            <source ref="id13"/>
            <target ref="id9"/>
            <label kind="guard" x="-255" y="-59">served[id-1]</label>
            <label kind="synchronisation" x="-255" y="-42">stop_h_action!</label>
            <label kind="assignment" x="-144" y="-59">t = 0, hExe = 0, Fp = F, 
oldPosX=humanPositionX[id-1],
oldPosY=humanPositionY[id-1],
updateTimer=0</label>
            <nail x="-272" y="-42"/>
        </transition>
        <transition>
            <source ref="id13"/>
            <target ref="id10"/>
            <label kind="guard" x="110" y="-144">!served[id-1]</label>
            <label kind="assignment" x="110" y="-127">updateP(v),
updateF(-lambda, 1),
updateTimer=0,
freeWill = random(freeWillRange)</label>
            <nail x="204" y="-127"/>
        </transition>
        <transition>
            <source ref="id10"/>
            <target ref="id13"/>
            <label kind="guard" x="297" y="-144">updateTimer&gt;=pollTime</label>
            <label kind="assignment" x="297" y="-127">checkSuccess()</label>
            <nail x="297" y="-127"/>
        </transition>
        <transition>
            <source ref="id9"/>
            <target ref="id9"/>
            <label kind="guard" x="-526" y="-118">updateTimer&gt;=pollTime</label>
            <label kind="assignment" x="-527" y="-102">updateP(0),
updateF(-mi, 0),
updateTimer=0,
freeWill = random(freeWillRange)</label>
            <nail x="-356" y="-118"/>
            <nail x="-407" y="-118"/>
        </transition>
        <transition>
            <source ref="id10"/>
            <target ref="id12"/>
            <label kind="guard" x="272" y="-238">F &gt;= passout_th</label>
            <label kind="synchronisation" x="289" y="-221">pass_out!</label>
            <label kind="assignment" x="289" y="-204">t = 0, hExe = 0</label>
        </transition>
        <transition>
            <source ref="id12"/>
            <target ref="id12"/>
            <nail x="400" y="-170"/>
            <nail x="442" y="-170"/>
        </transition>
        <transition>
            <source ref="id11"/>
            <target ref="id9"/>
            <label kind="assignment" x="-510" y="-221">initHuman()</label>
        </transition>
    </template>
    <template>
        <name>Human_Recipient</name>
        <parameter>int id, int v, int p_f, int p_fw</parameter>
        <declaration>clock h, t, F, Fp;
clock updateTimer;
clock freeWill;

double lambda = 0.005, mi = 0.005;
double MET = 60.0;
double passout_th = 1.0;

// Free Will Model
int obey;
int disobey;
int freeWillRange = 100;
int freeWillTh = 101;

// Fatigue Sharing Parameters
int pollTime = 2;

// Position Sharing Parameters
int timeP = 0;
bool recovered = true;
double oldPosX;
double oldPosY;

void updateF(double coeff, bool walking) {
    if(walking) {
        humanFatigue[id-1] = 1-(1-humanFatigue[id-1])*exp(coeff*pollTime); 
    } else {
        humanFatigue[id-1] = humanFatigue[id-1]*exp(coeff*pollTime);
    }

    humanFatigue[id-1] = fmax(0, humanFatigue[id-1]);
}

bool destIsOnTheLeft, destIsOnTheRight, destIsAhead, destIsBehind;
bool flip = false;
double allowanceFactor = 0.95;

double calculateAtoBdistance(point pointA, point pointB) {
    double xdifference = pow(pointA[0]-pointB[0], 2);
    double ydifference = pow(pointA[1]-pointB[1], 2);
    double distance = sqrt(xdifference + ydifference)/100;
    if(distance&lt;0) {
        return -distance;
    } else {
        return distance;
    }
}

point dest1 = {1000.0, 300.0};
point dest2 = {300.0, 300.0};
double dX;
double dY;
void changeDirection() {
    double inverseValue, turnLeft, turnRight, length=2000.0, height=100.0;
    double toCheck, humThF, humThB;   
    point pos = {humanPositionX[id-1], humanPositionY[id-1]};
    destIsOnTheLeft = false; destIsOnTheRight = false; destIsAhead = false; destIsBehind = false;

    if(calculateAtoBdistance(dest1, pos) &lt; 1) {
        dX = dest2[0];
        dY = dest2[1];
    }
    if(calculateAtoBdistance(dest2, pos) &lt; 1) {
        dX = dest1[0];
        dY = dest1[1];
    }

    if(humTheta[id-1] == 0) {
        inverseValue = -pi; turnLeft = pi/2; turnRight = -pi/2;
        toCheck = humanPositionX[id-1];
        humThF = allowanceFactor*HALL2_4[0];
        humThB = HALL2_1[0]+(1-allowanceFactor)*HALL2_1[0];
        destIsOnTheLeft = isInRectangle(pos, dX, dY, height, length);
        destIsOnTheRight = isInRectangle(pos, dX, dY, height, -length);
        destIsAhead = isInRectangle(pos, dX, dY, length, height);
        destIsBehind = isInRectangle(pos, dX, dY, -length, height);
    } else if (humTheta[id-1] == -pi) {
        inverseValue = 0.0; turnLeft = -pi/2; turnRight = pi/2;
        toCheck = humanPositionX[id-1];
        humThF = allowanceFactor*HALL2_4[0];
        humThB = HALL2_1[0]+(1-allowanceFactor)*HALL2_1[0];
        destIsOnTheLeft = isInRectangle(pos, dX, dY, height, -length);
        destIsOnTheRight = isInRectangle(pos, dX, dY, height, length);
        destIsAhead = isInRectangle(pos, dX, dY, -length, height);
        destIsBehind = isInRectangle(pos, dX, dY, length, height);
    } else if (humTheta[id-1] == pi/2) {
        inverseValue = -pi/2; turnLeft = -pi; turnRight = 0;
        toCheck = humanPositionY[id-1];
        humThF = allowanceFactor*HALL1_4[1];
        humThB = HALL2_4[1]+(1-allowanceFactor);
        destIsOnTheLeft = isInRectangle(pos, dX, dY, -length, height);
        destIsOnTheRight = isInRectangle(pos, dX, dY, length, height);
        destIsAhead = isInRectangle(pos, dX, dY, height, length);
        destIsBehind = isInRectangle(pos, dX, dY, height, -length);
    } else if (humTheta[id-1] == -pi/2) {
        inverseValue = pi/2; turnLeft = 0; turnRight = -pi;      
        toCheck = humanPositionY[id-1];
        humThF = allowanceFactor*HALL1_4[1];
        humThB = HALL2_4[1]+(1-allowanceFactor);
        destIsOnTheLeft = isInRectangle(pos, dX, dY, length, height);
        destIsOnTheRight = isInRectangle(pos, dX, dY, -length, height);
        destIsAhead = isInRectangle(pos, dX, dY, height, -length);
        destIsBehind = isInRectangle(pos, dX, dY, height, length);
    }

    // should change direction if wall is close, 
    // or destination is not reachable with current direction
    if(recovered) {
        if(destIsAhead) {
            return;
        } else if(destIsBehind || toCheck &lt; humThB || toCheck &gt; humThF) { //should turn 180 deg
            humTheta[id-1] = inverseValue;
            timeP = 0;
            recovered = false;
            oldPosX = humanPositionX[id-1];
            oldPosY = humanPositionY[id-1];   
        } else if (destIsOnTheLeft) { //should turn left
            humTheta[id-1] = turnLeft;
            timeP = 0;
            oldPosX = humanPositionX[id-1];
            oldPosY = humanPositionY[id-1];   
        } else if (destIsOnTheRight) { //should turn right
            humTheta[id-1] = turnRight;
            timeP = 0;
            oldPosX = humanPositionX[id-1];
            oldPosY = humanPositionY[id-1];   
        } 
    } else {
        recovered = toCheck &gt; humThB &amp;&amp; toCheck &lt; humThF;
    }
}

void updateP(double coeff) {
    double h;
    //!!!!!!!!!!! TODO: perchè senza currH &lt; 3 non funziona?
    if(coeff&gt;0 &amp;&amp; currH&lt;=3) {
        changeDirection();
        timeP += pollTime;
    }

    h = coeff*timeP;

    humanPositionX[id-1] = oldPosX + h*cos(humTheta[id-1]);
    humanPositionY[id-1] = oldPosY + h*sin(humTheta[id-1]);
}

void updateFreeWill(){
    if(currH==id) {
        freeWillRange = 100;
        freeWillTh = 99;
    } else {
        freeWill = 0;
        freeWillRange = 10;
        freeWillTh = 20;
    }
}

void initHuman() {
    F = 0; 
    Fp = 0;
    t = 0;
    h = 0;
    
    updateTimer = 0;
    humanPositionX[id-1] = HALL1_1[0]+20;
    humanPositionY[id-1] = HALL2_1[1] + (HALL1_1[1]-HALL2_1[1])/2 + 25;
    oldPosX = humanPositionX[id-1];
    oldPosY = humanPositionY[id-1];

    // unfortunately the switch case is not supported yet
    if(p_f==1) {
        lambda = young_healthy[0]; mi = young_healthy[1];
    } else if(p_f==2) {
        lambda = young_sick[0]; mi = young_sick[1];
    } else if(p_f==3) {
        lambda = elder_healthy[0]; mi = elder_healthy[1];
    } else if(p_f==4) {
        lambda = elder_sick[0]; mi = elder_sick[1];
    } else if(p_f==5) {
        lambda = covid_patient[0]; mi = covid_patient[1];
    } else {
        lambda = 0.005; mi = 0.005; //default values
    }

    if(p_fw==1) {
        freeWillTh = grownup;
    } else if(p_fw == 2) {
        freeWillTh = childlike;
    } else if(p_fw == 3) {
        freeWillTh = whatever;
    }

}</declaration>
        <location id="id15" x="-399" y="-297">
            <name x="-433" y="-323">idle</name>
            <label kind="invariant" x="-484" y="-442">t' == 1 
&amp;&amp; h' == 0 
&amp;&amp; Fp' == 0
&amp;&amp; F' == -Fp*mi*exp(-mi*t)
&amp;&amp; freeWill' == 0
&amp;&amp; updateTimer
&lt;=pollTime</label>
        </location>
        <location id="id16" x="212" y="-297">
            <name x="204" y="-331">busy_mov</name>
            <label kind="invariant" x="204" y="-433">t' == 1 &amp;&amp; h'  == v 
&amp;&amp; Fp' == 0
&amp;&amp; F &lt;= passout_th 
&amp;&amp; freeWill' == 0 
&amp;&amp; F' == Fp*lambda*exp(-lambda*t)
&amp;&amp; updateTimer&lt;=pollTime</label>
        </location>
        <location id="id17" x="-594" y="-296">
            <name x="-637" y="-313">Init</name>
            <committed/>
        </location>
        <location id="id18" x="365" y="-297">
            <name x="382" y="-314">passed_out</name>
            <label kind="invariant" x="382" y="-297">t' == 0 &amp;&amp;
F' == 0 &amp;&amp;
h' == 0 &amp;&amp;
freeWill' == 0</label>
            <label kind="exponentialrate" x="357" y="-280">1</label>
        </location>
        <location id="id19" x="-102" y="-467">
            <name x="-93" y="-459">busy_rec</name>
            <label kind="invariant" x="-93" y="-595">t' == 1 &amp;&amp; h' == 0 
&amp;&amp; Fp' == 0
&amp;&amp; F' == -Fp*mi*exp(-mi*t)
&amp;&amp; freeWill' == 0
&amp;&amp; updateTimer
&lt;=pollTime</label>
        </location>
        <init ref="id17"/>
        <transition>
            <source ref="id19"/>
            <target ref="id19"/>
            <label kind="guard" x="-221" y="-637">updateTimer&gt;=pollTime</label>
            <label kind="assignment" x="-221" y="-688">updateP(0), updateF(-mi, 0),
updateTimer=0,
freeWill = random(freeWillRange)</label>
            <nail x="-221" y="-612"/>
            <nail x="-102" y="-612"/>
        </transition>
        <transition>
            <source ref="id19"/>
            <target ref="id15"/>
            <label kind="synchronisation" x="-263" y="-484">stop_h_action?</label>
            <label kind="assignment" x="-391" y="-544">t = 0, freeWill = 0, timeP = 0, Fp = F,
oldPosX=humanPositionX[id-1],
oldPosY=humanPositionY[id-1],
updateTimer=0,
updateFreeWill()</label>
            <nail x="-263" y="-467"/>
        </transition>
        <transition>
            <source ref="id16"/>
            <target ref="id19"/>
            <label kind="synchronisation" x="229" y="-552">start_h_action[id]?</label>
            <label kind="assignment" x="110" y="-535">t = 0, freeWill = 0, timeP = 0, Fp = F,
oldPosX=humanPositionX[id-1],
oldPosY=humanPositionY[id-1],
updateTimer=0,
updateFreeWill()</label>
            <nail x="85" y="-467"/>
        </transition>
        <transition>
            <source ref="id15"/>
            <target ref="id19"/>
            <label kind="synchronisation" x="-246" y="-442">start_h_action[id]?</label>
            <label kind="assignment" x="-246" y="-425">F = 0, t = 0,
updateTimer=0</label>
            <nail x="-246" y="-442"/>
        </transition>
        <transition>
            <source ref="id16"/>
            <target ref="id15"/>
            <label kind="guard" x="-263" y="-255">freeWill&gt;=freeWillTh</label>
            <label kind="synchronisation" x="-263" y="-238">free_stop!</label>
            <label kind="assignment" x="-110" y="-255">t = 0, freeWill = 0, timeP = 0, Fp = F,
oldPosX=humanPositionX[id-1],
oldPosY=humanPositionY[id-1],
updateTimer=0,
updateFreeWill()</label>
            <nail x="93" y="-255"/>
            <nail x="-289" y="-255"/>
        </transition>
        <transition>
            <source ref="id15"/>
            <target ref="id16"/>
            <label kind="guard" x="-264" y="-340">freeWill&gt;=freeWillTh</label>
            <label kind="synchronisation" x="-263" y="-323">free_start!</label>
            <label kind="assignment" x="-102" y="-340">t = 0, Fp = F,
updateTimer=0,
freeWill = 0</label>
            <nail x="-280" y="-340"/>
            <nail x="93" y="-340"/>
        </transition>
        <transition>
            <source ref="id16"/>
            <target ref="id16"/>
            <label kind="guard" x="213" y="-195">updateTimer&gt;=pollTime</label>
            <label kind="assignment" x="213" y="-178">updateP(v), updateF(-lambda, 1),
updateTimer=0,
freeWill = random(freeWillRange)</label>
            <nail x="213" y="-195"/>
            <nail x="264" y="-195"/>
        </transition>
        <transition>
            <source ref="id15"/>
            <target ref="id15"/>
            <label kind="guard" x="-568" y="-194">updateTimer&gt;=pollTime</label>
            <label kind="assignment" x="-569" y="-178">updateP(0), updateF(-mi, 0),
updateTimer=0,
freeWill = random(freeWillRange)</label>
            <nail x="-398" y="-194"/>
            <nail x="-449" y="-194"/>
        </transition>
        <transition>
            <source ref="id16"/>
            <target ref="id18"/>
            <label kind="guard" x="230" y="-314">F &gt;= passout_th</label>
            <label kind="synchronisation" x="255" y="-297">pass_out!</label>
            <label kind="assignment" x="306" y="-280">t = 0</label>
        </transition>
        <transition>
            <source ref="id18"/>
            <target ref="id18"/>
            <nail x="340" y="-246"/>
            <nail x="382" y="-246"/>
        </transition>
        <transition>
            <source ref="id17"/>
            <target ref="id15"/>
            <label kind="assignment" x="-552" y="-289">initHuman()</label>
        </transition>
    </template>
    <template>
        <name>Robot</name>
        <parameter>int id, int v_max, int a_max</parameter>
        <declaration>clock V, r;
clock updateTimer;

// Position Sharing parameters
int posCounter = 0;
int pollTime = 1;
double oldPosX;
double oldPosY;

void initRobot() {
    V = 0;
    r = 0;
    robPositionX = HALL1_1[0]+20.0;
    robPositionY = HALL2_1[1] + (HALL1_1[1]-HALL2_1[1])/2;
    oldPosX = robPositionX;
    oldPosY = robPositionY;
    updateTimer=0;
}

void update(double coeff, bool reset) {
    double r;
    if(!robTurned) {
        oldPosX = robPositionX;
        oldPosY = robPositionY;
    }

    if(reset || !robTurned) {
        posCounter = 0;
    } else {
        posCounter += pollTime;
    }

    if(coeff&lt;0){
        r = coeff*(posCounter+0.5) + v_max; 
    } else {
        r = coeff*(posCounter+0.5); 
    }

    robPositionX = oldPosX + r*cos(robTheta);    
    robPositionY = oldPosY + r*sin(robTheta);                   
}

void varsUpdate(double coeff, bool reset) {
    oldPosX=robPositionX;
    oldPosY=robPositionY;
    update(coeff, reset);
    updateTimer=0;
}


</declaration>
        <location id="id20" x="-629" y="-348">
            <name x="-672" y="-365">idle</name>
            <label kind="invariant" x="-791" y="-348">V' == 0 &amp;&amp; r' == 0 &amp;&amp;
updateTimer'==0</label>
        </location>
        <location id="id21" x="-424" y="-144">
            <name x="-492" y="-136">stopping</name>
            <label kind="invariant" x="-543" y="-119">V' == -a_max 
&amp;&amp; r' == V 
&amp;&amp; V &gt;=0
&amp;&amp; updateTimer
&lt;=pollTime</label>
        </location>
        <location id="id22" x="-425" y="-348">
            <name x="-408" y="-366">starting</name>
            <label kind="invariant" x="-331" y="-433">V' == a_max 
&amp;&amp; V &lt;= v_max 
&amp;&amp; r' == V
&amp;&amp; updateTimer
&lt;=pollTime</label>
        </location>
        <location id="id23" x="-161" y="-246">
            <name x="-229" y="-263">moving</name>
            <label kind="invariant" x="-254" y="-246">V' == 0 &amp;&amp; 
r' == V &amp;&amp; 
updateTimer&lt;=pollTime</label>
        </location>
        <location id="id24" x="-629" y="-527">
            <name x="-639" y="-561">Init</name>
            <committed/>
        </location>
        <location id="id25" x="-850" y="-459">
            <name x="-952" y="-467">recharging</name>
            <label kind="invariant" x="-1003" y="-450">V'==0 &amp;&amp; r' == 0 &amp;&amp;
updateTimer'==0</label>
        </location>
        <init ref="id24"/>
        <transition>
            <source ref="id21"/>
            <target ref="id22"/>
            <label kind="guard" x="-416" y="-306">V&gt;0</label>
            <label kind="synchronisation" x="-416" y="-289">start_r_action[id]?</label>
            <label kind="assignment" x="-416" y="-272">varsUpdate(v_max, 1)</label>
        </transition>
        <transition>
            <source ref="id22"/>
            <target ref="id21"/>
            <label kind="guard" x="-527" y="-306">V&lt;v_max</label>
            <label kind="synchronisation" x="-561" y="-289">stop_r_action?</label>
            <label kind="assignment" x="-612" y="-272">varsUpdate(v_max, 1)</label>
            <nail x="-459" y="-323"/>
            <nail x="-459" y="-161"/>
        </transition>
        <transition>
            <source ref="id21"/>
            <target ref="id21"/>
            <label kind="guard" x="-424" y="-42">updateTimer&gt;=pollTime
&amp;&amp;V&lt;v_max</label>
            <label kind="assignment" x="-424" y="-8">varsUpdate(-a_max, 0)</label>
            <nail x="-424" y="-42"/>
            <nail x="-381" y="-42"/>
        </transition>
        <transition>
            <source ref="id23"/>
            <target ref="id23"/>
            <label kind="guard" x="-60" y="-280">updateTimer&gt;=pollTime</label>
            <label kind="assignment" x="-59" y="-263">update(v_max, 0),
updateTimer=0</label>
            <nail x="-68" y="-271"/>
            <nail x="-68" y="-229"/>
        </transition>
        <transition>
            <source ref="id22"/>
            <target ref="id22"/>
            <label kind="guard" x="-424" y="-501">updateTimer&gt;=pollTime
&amp;&amp;V&lt;v_max</label>
            <label kind="assignment" x="-424" y="-467">varsUpdate(a_max, 0)</label>
            <nail x="-425" y="-442"/>
            <nail x="-391" y="-442"/>
        </transition>
        <transition>
            <source ref="id25"/>
            <target ref="id20"/>
            <label kind="synchronisation" x="-816" y="-493">stop_recharging?</label>
            <label kind="assignment" x="-816" y="-476">updateTimer=0</label>
            <nail x="-629" y="-459"/>
        </transition>
        <transition>
            <source ref="id20"/>
            <target ref="id25"/>
            <label kind="synchronisation" x="-842" y="-416">start_recharging[id]?</label>
            <nail x="-850" y="-348"/>
        </transition>
        <transition>
            <source ref="id21"/>
            <target ref="id20"/>
            <label kind="guard" x="-688" y="-238">V &lt;= 0</label>
            <label kind="assignment" x="-790" y="-221">varsUpdate(-a_max, 1)</label>
            <nail x="-628" y="-144"/>
        </transition>
        <transition>
            <source ref="id23"/>
            <target ref="id21"/>
            <label kind="synchronisation" x="-331" y="-144">stop_r_action?</label>
            <label kind="assignment" x="-330" y="-127">varsUpdate(v_max, 1)</label>
            <nail x="-160" y="-144"/>
        </transition>
        <transition>
            <source ref="id22"/>
            <target ref="id23"/>
            <label kind="guard" x="-153" y="-348">V &gt;= v_max</label>
            <label kind="assignment" x="-153" y="-331">varsUpdate(a_max, 1)</label>
            <nail x="-161" y="-348"/>
        </transition>
        <transition>
            <source ref="id20"/>
            <target ref="id22"/>
            <label kind="synchronisation" x="-595" y="-374">start_r_action[id]?</label>
        </transition>
        <transition>
            <source ref="id24"/>
            <target ref="id20"/>
            <label kind="assignment" x="-621" y="-484">initRobot()</label>
        </transition>
    </template>
    <template>
        <name>Battery</name>
        <parameter>int id, int Cstart</parameter>
        <declaration>clock C, t, tUpd;

// Discharge tresholds
int C_100 = 100;
int C_80 = 80;
int C_20 = 20;

// Charge/Discharge Rate R:
// R = 1/Tcycle * ln(100/0.01)
double R = 0.00102;
double cheatFactor = 10.0;

// BatteryStatus Sharing parameters
//int chargeCounter = 0;
int Tpoll = 10;
double Cp;

void updateCharge(bool charging) {
    double increment;

    increment = 100 - batteryCharge;

    if(charging) {
        batteryCharge = 100 - increment*exp(-R*Tpoll); 
    } else {
        batteryCharge = 100 - increment*exp(R*Tpoll);
    }
}

void initBattery() {
    t=0;

    if(Cstart==C_100) {
        Cp = 99.99;    
    } else {
        Cp = Cstart;
    }
    C = Cp;
    batteryCharge = Cp;
    tUpd=0;
}





</declaration>
        <location id="id26" x="408" y="204">
            <name x="382" y="170">Init</name>
            <label kind="exponentialrate" x="383" y="187">1</label>
            <committed/>
        </location>
        <location id="id27" x="1003" y="204">
            <name x="1020" y="179">empty</name>
            <label kind="invariant" x="1020" y="196">C'==0</label>
            <label kind="exponentialrate" x="1020" y="162">1</label>
        </location>
        <location id="id28" x="688" y="204">
            <name x="696" y="170">discharging</name>
            <label kind="invariant" x="696" y="119">C' == -(100-Cp)*R*exp(R*t)
&amp;&amp; C&gt;=0 &amp;&amp; t'==1
&amp;&amp; tUpd &lt;= Tpoll</label>
        </location>
        <location id="id29" x="688" y="425">
            <name x="705" y="425">recharging</name>
            <label kind="invariant" x="705" y="442">C' == (100-Cp)*R*exp(-R*t)
&amp;&amp; C &lt; C_100 &amp;&amp; t'==1
&amp;&amp; tUpd &lt;= Tpoll</label>
        </location>
        <location id="id30" x="399" y="425">
            <name x="391" y="442">fully_recharged</name>
        </location>
        <init ref="id26"/>
        <transition>
            <source ref="id30"/>
            <target ref="id28"/>
            <label kind="synchronisation" x="484" y="289">full_battery!</label>
            <nail x="484" y="280"/>
        </transition>
        <transition>
            <source ref="id28"/>
            <target ref="id30"/>
            <label kind="guard" x="374" y="255">C&gt;=C_100</label>
            <label kind="synchronisation" x="331" y="280">start_recharging[id]?</label>
            <label kind="assignment" x="331" y="297">Cp=C, t=0, tUpd = 0</label>
            <nail x="425" y="246"/>
        </transition>
        <transition>
            <source ref="id29"/>
            <target ref="id30"/>
            <label kind="guard" x="450" y="408">C&gt;=C_100</label>
            <label kind="assignment" x="535" y="408">tUpd = 0</label>
        </transition>
        <transition>
            <source ref="id26"/>
            <target ref="id28"/>
            <label kind="assignment" x="493" y="178">initBattery()</label>
        </transition>
        <transition>
            <source ref="id29"/>
            <target ref="id28"/>
            <label kind="guard" x="603" y="263">C&lt;C_100 &amp;&amp;
tUpd&lt;Tpoll</label>
            <label kind="synchronisation" x="603" y="306">stop_recharging?</label>
            <label kind="assignment" x="603" y="323">Cp=C, t=0, tUpd = 0</label>
        </transition>
        <transition>
            <source ref="id29"/>
            <target ref="id29"/>
            <label kind="guard" x="646" y="518">tUpd &gt;= Tpoll &amp;&amp; C &lt; C_100</label>
            <label kind="assignment" x="646" y="535">updateCharge(1), tUpd = 0</label>
            <nail x="646" y="518"/>
            <nail x="688" y="518"/>
        </transition>
        <transition>
            <source ref="id28"/>
            <target ref="id28"/>
            <label kind="guard" x="637" y="51">tUpd &gt;= Tpoll &amp;&amp; C &gt; 0</label>
            <label kind="assignment" x="637" y="68">updateCharge(0),
tUpd = 0</label>
            <nail x="637" y="111"/>
            <nail x="688" y="111"/>
        </transition>
        <transition>
            <source ref="id28"/>
            <target ref="id29"/>
            <label kind="guard" x="756" y="289">C&lt;C_100</label>
            <label kind="synchronisation" x="748" y="331">start_recharging[id]?</label>
            <label kind="assignment" x="739" y="348">Cp=C, t=0, tUpd = 0</label>
            <nail x="756" y="314"/>
        </transition>
        <transition>
            <source ref="id27"/>
            <target ref="id27"/>
            <nail x="1020" y="247"/>
            <nail x="1046" y="230"/>
        </transition>
        <transition>
            <source ref="id28"/>
            <target ref="id27"/>
            <label kind="guard" x="926" y="187">C&lt;=0</label>
            <label kind="synchronisation" x="884" y="204">dead_battery!</label>
        </transition>
    </template>
    <template>
        <name>Orchestrator</name>
        <parameter>int humansToServe</parameter>
        <declaration>clock actionTimer;

//Decision-Making Parameters
int timerInterval = 5;
int processingTime = 1;

//Moving Policy Parameters
bool aStart = false;
bool aStop = false;
double stopDistance = 2.0; // [m]
double restartDistance = 1.0; // [m]

//Recharging Policy Parameters
bool recharge = false;
bool stopRecharge = false;
double rechargingTh = 10.0;
double stopRechargingTh = 75.0;
double failBattery = 1.0;

//Fatigue-Monitoring Parameters
double failFatigue = 0.97;
double stopFatigue = 0.9;
double resumeFatigue = 0.3;

double allowanceFactor = 0.95, humanRobotDist;
bool destIsOnTheLeft, destIsOnTheRight, destIsAhead, destIsBehind;
bool humanCanStart = false;
bool humanShouldStop = false;
double dX, dY;
void changeDirection() {
    double inverseValue, turnLeft, turnRight, length=2000.0, height=100.0;
    double toCheck, robThF, robThB;   
    point pos = {robPositionX, robPositionY}; 

    if(patterns[currH-1]==1 || (patterns[currH-1]==0 &amp;&amp; !humanCanStart)) {
        dX = humanPositionX[currH-1];
        dY = humanPositionY[currH-1];
    } else if(aStart &amp;&amp; recharge) {
        dX = rechargeStation[0];
        dY = rechargeStation[1];
    } else {
        dX = destX[currH-1];
        dY = destY[currH-1];
    }

    destIsOnTheLeft = false; destIsOnTheRight = false; destIsAhead = false; destIsBehind = false;
    if(robTheta == 0) {
        inverseValue = -pi; turnLeft = pi/2; turnRight = -pi/2;
        toCheck = robPositionX;
        robThF = allowanceFactor*HALL2_4[0];
        if(robPositionX &gt; HALL1_3[0] &amp;&amp; (robPositionY &gt; HALL1_2[1] || robPositionY &lt; HALL2_2[1])) {
            robThB = HALL1_3[0]+(1-allowanceFactor)*HALL1_3[0];
        } else {
            robThB = HALL2_1[0]+(1-allowanceFactor)*HALL2_1[0];        
        }
        destIsOnTheLeft = isInRectangle(pos, dX, dY, height, length);
        destIsOnTheRight = isInRectangle(pos, dX, dY, height, -length);
        destIsAhead = isInRectangle(pos, dX, dY, length, height);
        destIsBehind = isInRectangle(pos, dX, dY, -length, height);
    } else if (robTheta == -pi) {
        inverseValue = 0.0; turnLeft = -pi/2; turnRight = pi/2;
        toCheck = robPositionX;
        robThF = allowanceFactor*HALL2_4[0];
        if(robPositionX &gt; HALL1_3[0] &amp;&amp; (robPositionY &gt; HALL1_2[1] || robPositionY &lt; HALL2_2[1])) {
            robThB = HALL1_3[0]+(1-allowanceFactor)*HALL1_3[0];
        } else {
            robThB = HALL2_1[0]+(1-allowanceFactor)*HALL2_1[0];        
        }
        destIsOnTheLeft = isInRectangle(pos, dX, dY, height, -length);
        destIsOnTheRight = isInRectangle(pos, dX, dY, height, length);
        destIsAhead = isInRectangle(pos, dX, dY, -length, height);
        destIsBehind = isInRectangle(pos, dX, dY, length, height);
    } else if (robTheta == pi/2) {
        inverseValue = -pi/2; turnLeft = -pi; turnRight = 0;
        toCheck = robPositionY;
        if(robPositionX &gt; HALL2_2[0]) {
            robThF = allowanceFactor*HALL1_4[1];
            robThB = HALL2_4[1]+(1-allowanceFactor);
        } else {
            robThF = allowanceFactor*HALL1_2[1];
            robThB = HALL2_2[1]+(1-allowanceFactor);
        }
        destIsOnTheLeft = isInRectangle(pos, dX, dY, -length, height);
        destIsOnTheRight = isInRectangle(pos, dX, dY, length, height);
        destIsAhead = isInRectangle(pos, dX, dY, height, length);
        destIsBehind = isInRectangle(pos, dX, dY, height, -length);
    } else if (robTheta == -pi/2) {
        inverseValue = pi/2; turnLeft = 0; turnRight = -pi;      
        toCheck = robPositionY;
        if(robPositionX &gt; HALL2_2[0]) {
            robThF = allowanceFactor*HALL1_4[1];
            robThB = HALL2_4[1]+(1-allowanceFactor);
        } else {
            robThF = allowanceFactor*HALL1_2[1];
            robThB = HALL2_2[1]+(1-allowanceFactor);
        }
        destIsOnTheLeft = isInRectangle(pos, dX, dY, length, height);
        destIsOnTheRight = isInRectangle(pos, dX, dY, -length, height);
        destIsAhead = isInRectangle(pos, dX, dY, height, -length);
        destIsBehind = isInRectangle(pos, dX, dY, height, length);
    }

    // should change direction if wall is close, 
    // or destination is not reachable with current direction
    if(robTurned) {
        if(destIsAhead) {
            return;
        } else if(destIsBehind || toCheck &lt; robThB || toCheck &gt; robThF) { //should turn 180 deg
            robTheta = inverseValue;
            robTurned = false;
        } else if (destIsOnTheLeft) { //should turn left
            robTheta = turnLeft;
            robTurned = false;
        } else if (destIsOnTheRight) { //should turn right
            robTheta = turnRight;
            robTurned = false;
        } 
    } else {
       robTurned = toCheck &gt; robThB &amp;&amp; toCheck &lt; robThF;     
    }
}

void checkSuccess() {
    bool robXinDestInterval = robPositionX &gt;= destX[currH-1]-50.0 &amp;&amp; robPositionX &lt;= destX[currH-1]+50.0;
    bool robYinDestInterval = robPositionY &gt;= destY[currH-1]-50.0 &amp;&amp; robPositionY &lt;= destY[currH-1]+50.0;
    humanRobotDist = calculateDistance();

    if (patterns[currH-1] == 1 &amp;&amp; served[currH-1] == true) {
            currH++; 
    }

    if(robXinDestInterval &amp;&amp; robYinDestInterval) {
        // If the currently served human is not leading,
        // the robot controller can determine when
        // he/she is served
        if(humanRobotDist &lt; stopDistance &amp;&amp; patterns[currH-1]==0) {
            humanCanStart = false;
            served[currH-1] = true;
            currH++; 
        } else if (patterns[currH-1] == 2 &amp;&amp; !objectTaken[currH-1]) {
            humanCanStart = true;
            objectTaken[currH-1] = true;
            destX[currH-1] = humanPositionX[currH-1];
            destY[currH-1] = humanPositionY[currH-1];
        } else if (patterns[currH-1] == 2 &amp;&amp; objectTaken[currH-1]) {
            humanCanStart = false;
            served[currH-1] = true;
            currH++;
        }
    }
    // If all humans have been served, 
    // mission is accomplished
    if(served[humansToServe-1]) {
       success = true;
    }
}

bool checkFatigue() {
     if(humanFatigue[currH-1]&gt;=stopFatigue) { 
        humanShouldStop = true;
         if(aStart) {
            aStart = false;
            aStop = true;     
         }            
        return true;
     }
    return false;
} 

void checkActions() {
    bool robXinDestInterval , robYinDestInterval;

    checkSuccess();
    if(!success &amp;&amp; currH &lt;= humansToServe) {
        // distance between human and robot [m]
        humanRobotDist = calculateDistance();
        // determines when to change direction, 
        // based on curr position and floor plan
        changeDirection();
    

        /**
        * Recharge policies
        **/
        if(!recharge &amp;&amp; batteryCharge&lt;=rechargingTh 
                &amp;&amp; ((!aStart &amp;&amp; patterns[currH-1]==1)|| patterns[currH-1]!=1)) { // when to move to recharge station
            recharge = true;
            stopRecharge = false;
            aStart = true;
            aStop = false;
            return;
        } 

        if(aStart &amp;&amp; recharge) { // when to stop because recharge station has been reached
            robXinDestInterval = robPositionX &gt;= rechargeStation[0]-50.0 &amp;&amp; robPositionX &lt;= rechargeStation[0]+50.0;
            robYinDestInterval = robPositionY &gt;= rechargeStation[1]-50.0 &amp;&amp; robPositionY &lt;= rechargeStation[1]+50.0;
            if(robXinDestInterval &amp;&amp; robYinDestInterval) {
                aStart = false;
                aStop = true;
            }     
            return;       
        } 

        if(recharge &amp;&amp; batteryCharge&gt;=stopRechargingTh) { // when to stop recharging
            recharge = false;
            stopRecharge = true;
            return;
        } 

        /**
        * Start&amp;Stop Policies
        **/    
        if(!recharge &amp;&amp; batteryCharge&lt;=rechargingTh &amp;&amp; aStart &amp;&amp; patterns[currH-1]!=1) {
            aStart = false;
            aStop = true;
            humanShouldStop = true;
            return;
        }

        // stop action due to energy reasons
        if(humanFatigue[currH-1]&gt;=stopFatigue) { 
            humanShouldStop = true;
            if(aStart) {
                aStart = false;
                aStop = true;     
            }            
            return;
        } 

        if(aStart &amp;&amp; (!humanCanStart || humanRobotDist &gt;= stopDistance) &amp;&amp; patterns[currH-1]!=2) { // stop due to excessive human-robot distance
            if(!humanCanStart &amp;&amp; humanRobotDist &lt; stopDistance) {
                humanCanStart = patterns[currH-1] == 0;
            } else {
                aStart = false;
                aStop = true;
                humanShouldStop = false;
            }   
            return; 
        } 

        // when to restart because distance has decreased
        if(!recharge &amp;&amp; !aStart &amp;&amp; humanRobotDist&lt;=restartDistance &amp;&amp; !humanShouldStop) { 
            aStart = true;
            aStop = false;
            humanCanStart = patterns[currH-1] == 0;
            return;
        } 

        // when to restart because fatigue has decreased
        if(!recharge &amp;&amp; !aStart &amp;&amp; humanFatigue[currH-1]&lt;=resumeFatigue &amp;&amp; humanShouldStop) {
            aStart = true;
            aStop = false;
            humanCanStart = patterns[currH-1] == 0;
            humanShouldStop = false;
            return;
        } 

        if(batteryCharge&lt;=failBattery || humanFatigue[currH-1]&gt;=failFatigue) { // when mission fails
            fail = true;
            return;
        }
    }
}

void resetActions() {
    recharge = false;
    stopRecharge = false;
    aStart = false;
    aStop = false;
}</declaration>
        <location id="id31" x="-952" y="-552">
            <name x="-1062" y="-646">idle</name>
            <label kind="invariant" x="-1062" y="-629">!aStart &amp;&amp; 
!recharge &amp;&amp;
actionTimer 
&lt;= timerInterval</label>
        </location>
        <location id="id32" x="-577" y="-552">
            <name x="-560" y="-569">exe_1</name>
            <label kind="invariant" x="-560" y="-552">!aStop &amp;&amp;
actionTimer 
&lt;= timerInterval</label>
        </location>
        <location id="id33" x="-1207" y="-552">
            <name x="-1343" y="-569">busy_recharging</name>
            <label kind="invariant" x="-1343" y="-552">!stopRecharge &amp;&amp;
actionTimer 
&lt;= timerInterval</label>
        </location>
        <location id="id34" x="-952" y="-391">
            <name x="-943" y="-382">actions_check_0</name>
            <label kind="invariant" x="-943" y="-365">actionTimer &lt;= 
processingTime</label>
        </location>
        <location id="id35" x="-1317" y="-654">
            <name x="-1436" y="-688">actions_check_1</name>
            <label kind="invariant" x="-1547" y="-671">actionTimer&lt;=processingTime</label>
        </location>
        <location id="id36" x="-458" y="-654">
            <name x="-450" y="-697">actions_check_2</name>
            <label kind="invariant" x="-450" y="-680">actionTimer &lt;= processingTime</label>
        </location>
        <location id="id37" x="-101" y="-748">
            <name x="-245" y="-782">mission_accomplished</name>
            <label kind="invariant" x="-246" y="-765">actionTimer'==0</label>
            <label kind="exponentialrate" x="-84" y="-773">1</label>
        </location>
        <location id="id38" x="-127" y="-374">
            <name x="-59" y="-399">mission_failed</name>
            <label kind="invariant" x="-59" y="-382">actionTimer'==0</label>
            <label kind="exponentialrate" x="-119" y="-365">1</label>
        </location>
        <location id="id39" x="-382" y="-374">
            <name x="-467" y="-365">forced_stop</name>
            <committed/>
        </location>
        <location id="id40" x="-646" y="-391">
            <name x="-654" y="-374">h_start</name>
            <committed/>
        </location>
        <location id="id41" x="-841" y="-748">
            <name x="-901" y="-773">h_stop</name>
            <committed/>
        </location>
        <location id="id42" x="-340" y="-748">
            <committed/>
        </location>
        <location id="id43" x="-127" y="-535">
            <name x="-178" y="-552">fail_2</name>
            <committed/>
        </location>
        <location id="id44" x="-552" y="-25">
            <name x="-535" y="-42">exe_2</name>
            <label kind="invariant" x="-535" y="-25">actionTimer 
&lt;= timerInterval</label>
        </location>
        <location id="id45" x="-433" y="-127">
            <name x="-425" y="-170">actions_check_3</name>
            <label kind="invariant" x="-425" y="-153">actionTimer &lt;= processingTime</label>
        </location>
        <location id="id46" x="-280" y="85">
            <name x="-365" y="94">forced_stop_2</name>
            <committed/>
        </location>
        <location id="id47" x="-195" y="-8">
            <name x="-229" y="0">fail_1</name>
            <committed/>
        </location>
        <location id="id48" x="-1207" y="-314">
            <name x="-1173" y="-357">mov_to_station</name>
            <label kind="invariant" x="-1173" y="-340">!aStop &amp;&amp;
actionTimer 
&lt;= timerInterval</label>
        </location>
        <location id="id49" x="-1428" y="-314">
            <name x="-1555" y="-322">actions_check_4</name>
            <label kind="invariant" x="-1649" y="-305">actionTimer&lt;=processingTime</label>
        </location>
        <location id="id50" x="-1317" y="-433">
            <name x="-1360" y="-493">stopping</name>
            <label kind="invariant" x="-1360" y="-476">actionTimer 
&lt;= timerInterval</label>
        </location>
        <init ref="id31"/>
        <transition>
            <source ref="id31"/>
            <target ref="id39"/>
            <label kind="synchronisation" x="-824" y="-569">pass_out?</label>
            <nail x="-782" y="-552"/>
            <nail x="-756" y="-433"/>
            <nail x="-629" y="-433"/>
        </transition>
        <transition>
            <source ref="id34"/>
            <target ref="id39"/>
            <label kind="synchronisation" x="-739" y="-348">pass_out?</label>
            <nail x="-629" y="-340"/>
        </transition>
        <transition>
            <source ref="id34"/>
            <target ref="id41"/>
            <label kind="guard" x="-1028" y="-858">!aStart &amp;&amp; !hExe &amp;&amp; humanShouldStop &amp;&amp;
actionTimer &gt;= processingTime</label>
            <nail x="-952" y="-816"/>
            <nail x="-841" y="-816"/>
        </transition>
        <transition>
            <source ref="id41"/>
            <target ref="id31"/>
            <label kind="guard" x="-1003" y="-714">!humanShouldStop</label>
            <nail x="-952" y="-748"/>
        </transition>
        <transition>
            <source ref="id49"/>
            <target ref="id47"/>
            <label kind="guard" x="-1547" y="-102">!aStop &amp;&amp; fail &amp;&amp;
actionTimer&gt;=
processingTime</label>
            <label kind="synchronisation" x="-1547" y="-51">stop_r_action!</label>
            <label kind="assignment" x="-1547" y="-34">actionTimer = 0</label>
            <nail x="-1428" y="42"/>
            <nail x="-374" y="42"/>
        </transition>
        <transition>
            <source ref="id48"/>
            <target ref="id46"/>
            <label kind="synchronisation" x="-1189" y="68">dead_battery?</label>
            <nail x="-1207" y="85"/>
        </transition>
        <transition>
            <source ref="id49"/>
            <target ref="id50"/>
            <label kind="guard" x="-1547" y="-450">aStop &amp;&amp;
actionTimer&gt;=
processingTime</label>
            <label kind="synchronisation" x="-1547" y="-399">stop_r_action!</label>
            <label kind="assignment" x="-1547" y="-382">actionTimer = 0</label>
            <nail x="-1428" y="-433"/>
        </transition>
        <transition>
            <source ref="id50"/>
            <target ref="id33"/>
            <label kind="guard" x="-1300" y="-433">actionTimer 
&gt;= timerInterval</label>
            <label kind="synchronisation" x="-1300" y="-399">start_recharging[currR]!</label>
            <label kind="assignment" x="-1300" y="-382">actionTimer = 0</label>
            <nail x="-1207" y="-433"/>
        </transition>
        <transition>
            <source ref="id49"/>
            <target ref="id48"/>
            <label kind="guard" x="-1394" y="-365">!aStop &amp;&amp; !fail &amp;&amp;
actionTimer&gt;=
processingTime</label>
        </transition>
        <transition>
            <source ref="id48"/>
            <target ref="id49"/>
            <label kind="guard" x="-1419" y="-254">actionTimer&gt;=timerInterval</label>
            <label kind="assignment" x="-1419" y="-238">checkActions(),
actionTimer = 0</label>
            <nail x="-1207" y="-254"/>
            <nail x="-1428" y="-254"/>
        </transition>
        <transition>
            <source ref="id34"/>
            <target ref="id48"/>
            <label kind="guard" x="-1173" y="-272">recharge &amp;&amp; !hExe &amp;&amp;
actionTimer &gt;= processingTime</label>
            <label kind="synchronisation" x="-1173" y="-238">start_r_action[currR]!</label>
            <label kind="assignment" x="-1173" y="-221">actionTimer = 0</label>
            <nail x="-986" y="-272"/>
            <nail x="-1156" y="-272"/>
        </transition>
        <transition>
            <source ref="id36"/>
            <target ref="id32"/>
            <label kind="guard" x="-824" y="-731">!aStop &amp;&amp; humanCanStart
&amp;&amp; !success &amp;&amp; !fail
&amp;&amp; actionTimer
&gt;=processingTime</label>
            <label kind="synchronisation" x="-824" y="-663">start_h_action[currH]!</label>
            <label kind="assignment" x="-824" y="-646">actionTimer=0</label>
            <nail x="-527" y="-714"/>
            <nail x="-688" y="-714"/>
            <nail x="-688" y="-552"/>
        </transition>
        <transition>
            <source ref="id40"/>
            <target ref="id32"/>
            <label kind="guard" x="-714" y="-518">humanCanStart</label>
            <label kind="synchronisation" x="-731" y="-501">start_h_action[currH]!</label>
            <nail x="-646" y="-552"/>
        </transition>
        <transition>
            <source ref="id45"/>
            <target ref="id37"/>
            <label kind="guard" x="-425" y="-263">!hExe &amp;&amp; success &amp;&amp;
actionTimer&gt;=processingTime</label>
            <label kind="synchronisation" x="-425" y="-229">stop_r_action!</label>
            <label kind="assignment" x="-323" y="-229">actionTimer = 0</label>
            <nail x="-433" y="-204"/>
            <nail x="34" y="-204"/>
            <nail x="34" y="-748"/>
        </transition>
        <transition>
            <source ref="id45"/>
            <target ref="id31"/>
            <label kind="guard" x="-603" y="-331">!hExe &amp;&amp; !success &amp;&amp; !fail
&amp;&amp; actionTimer&gt;= processingTime</label>
            <label kind="synchronisation" x="-602" y="-297">stop_r_action!</label>
            <label kind="assignment" x="-602" y="-280">actionTimer = 0,
resetActions()</label>
            <nail x="-620" y="-433"/>
            <nail x="-756" y="-433"/>
            <nail x="-782" y="-552"/>
        </transition>
        <transition>
            <source ref="id34"/>
            <target ref="id44"/>
            <label kind="guard" x="-943" y="-212">hExe &amp;&amp;
actionTimer &gt;= processingTime</label>
            <label kind="synchronisation" x="-986" y="-178">start_r_action[currR]!</label>
            <label kind="assignment" x="-943" y="-161">actionTimer = 0</label>
            <nail x="-952" y="-25"/>
        </transition>
        <transition>
            <source ref="id47"/>
            <target ref="id38"/>
            <nail x="-127" y="-8"/>
        </transition>
        <transition>
            <source ref="id46"/>
            <target ref="id38"/>
            <label kind="synchronisation" x="-238" y="59">stop_r_action!</label>
            <nail x="-127" y="85"/>
        </transition>
        <transition>
            <source ref="id39"/>
            <target ref="id38"/>
            <label kind="synchronisation" x="-314" y="-450">stop_r_action!</label>
            <label kind="assignment" x="-314" y="-433">actionTimer = 0,
resetActions(),
fail = true</label>
        </transition>
        <transition>
            <source ref="id43"/>
            <target ref="id38"/>
            <label kind="synchronisation" x="-119" y="-518">stop_h_action!</label>
        </transition>
        <transition>
            <source ref="id36"/>
            <target ref="id43"/>
            <label kind="guard" x="-119" y="-646">fail &amp;&amp;
actionTimer&gt;=
processingTime</label>
            <label kind="synchronisation" x="-119" y="-595">stop_r_action!</label>
            <label kind="assignment" x="-119" y="-578">actionTimer=0</label>
            <nail x="-127" y="-654"/>
        </transition>
        <transition>
            <source ref="id42"/>
            <target ref="id37"/>
            <label kind="synchronisation" x="-323" y="-748">stop_h_action!</label>
        </transition>
        <transition>
            <source ref="id36"/>
            <target ref="id42"/>
            <label kind="guard" x="-459" y="-824">success &amp;&amp;
actionTimer&gt;=processingTime</label>
            <label kind="synchronisation" x="-459" y="-790">stop_r_action!</label>
            <label kind="assignment" x="-459" y="-773">actionTimer=0</label>
            <nail x="-459" y="-748"/>
        </transition>
        <transition>
            <source ref="id40"/>
            <target ref="id32"/>
            <label kind="guard" x="-637" y="-467">!humanCanStart</label>
            <nail x="-577" y="-391"/>
        </transition>
        <transition>
            <source ref="id34"/>
            <target ref="id40"/>
            <label kind="guard" x="-934" y="-425">aStart &amp;&amp; !hExe &amp;&amp;
actionTimer &gt;= processingTime</label>
            <label kind="synchronisation" x="-807" y="-391">start_r_action[currR]!</label>
            <label kind="assignment" x="-807" y="-374">actionTimer = 0</label>
        </transition>
        <transition>
            <source ref="id41"/>
            <target ref="id31"/>
            <label kind="guard" x="-943" y="-680">humanShouldStop</label>
            <label kind="synchronisation" x="-943" y="-663">stop_h_action!</label>
            <nail x="-841" y="-552"/>
        </transition>
        <transition>
            <source ref="id36"/>
            <target ref="id41"/>
            <label kind="guard" x="-799" y="-824">aStop &amp;&amp;
!success &amp;&amp; !fail
&amp;&amp; actionTimer&gt;=
processingTime</label>
            <label kind="synchronisation" x="-663" y="-807">stop_r_action!</label>
            <label kind="assignment" x="-663" y="-790">actionTimer = 0,
resetActions()</label>
            <nail x="-501" y="-748"/>
        </transition>
        <transition>
            <source ref="id32"/>
            <target ref="id39"/>
            <label kind="synchronisation" x="-501" y="-459">pass_out?</label>
            <nail x="-535" y="-442"/>
            <nail x="-382" y="-442"/>
        </transition>
        <transition>
            <source ref="id32"/>
            <target ref="id39"/>
            <label kind="synchronisation" x="-501" y="-442">dead_battery?</label>
            <nail x="-535" y="-442"/>
            <nail x="-382" y="-442"/>
        </transition>
        <transition>
            <source ref="id37"/>
            <target ref="id37"/>
            <nail x="-152" y="-748"/>
            <nail x="-152" y="-731"/>
        </transition>
        <transition>
            <source ref="id38"/>
            <target ref="id38"/>
            <nail x="-68" y="-399"/>
            <nail x="-68" y="-374"/>
        </transition>
        <transition>
            <source ref="id35"/>
            <target ref="id31"/>
            <label kind="guard" x="-1300" y="-714">stopRecharge &amp;&amp;
actionTimer&gt;=
processingTime</label>
            <label kind="synchronisation" x="-1173" y="-714">stop_recharging!</label>
            <label kind="assignment" x="-1173" y="-697">actionTimer = 0,
resetActions()</label>
            <nail x="-1071" y="-654"/>
            <nail x="-1071" y="-552"/>
        </transition>
        <transition>
            <source ref="id32"/>
            <target ref="id36"/>
            <label kind="guard" x="-450" y="-612">actionTimer&gt;=timerInterval</label>
            <label kind="assignment" x="-450" y="-595">checkActions(),
actionTimer = 0</label>
            <nail x="-459" y="-552"/>
        </transition>
        <transition>
            <source ref="id36"/>
            <target ref="id32"/>
            <label kind="guard" x="-671" y="-688">!aStop &amp;&amp; !humanCanStart
&amp;&amp; !success &amp;&amp; !fail
&amp;&amp; actionTimer
&gt;=processingTime</label>
            <label kind="assignment" x="-671" y="-620">actionTimer=0</label>
            <nail x="-578" y="-594"/>
        </transition>
        <transition>
            <source ref="id35"/>
            <target ref="id33"/>
            <label kind="guard" x="-1198" y="-646">!stopRecharge &amp;&amp;
actionTimer&gt;=
processingTime</label>
            <label kind="assignment" x="-1198" y="-595">actionTimer=0</label>
            <nail x="-1207" y="-654"/>
        </transition>
        <transition>
            <source ref="id33"/>
            <target ref="id35"/>
            <label kind="guard" x="-1521" y="-637">actionTimer&gt;=timerInterval</label>
            <label kind="assignment" x="-1428" y="-620">checkActions(),
actionTimer = 0</label>
            <nail x="-1232" y="-603"/>
            <nail x="-1317" y="-603"/>
        </transition>
        <transition>
            <source ref="id34"/>
            <target ref="id31"/>
            <label kind="guard" x="-1096" y="-501">!aStart &amp;&amp;
!recharge &amp;&amp;
actionTimer &gt;= 
processingTime</label>
            <label kind="assignment" x="-1096" y="-518">actionTimer = 0</label>
            <nail x="-986" y="-475"/>
        </transition>
        <transition>
            <source ref="id31"/>
            <target ref="id34"/>
            <label kind="guard" x="-918" y="-518">actionTimer 
&gt;= timerInterval</label>
            <label kind="assignment" x="-918" y="-484">checkActions(),
actionTimer = 0</label>
            <nail x="-918" y="-476"/>
        </transition>
        <transition>
            <source ref="id45"/>
            <target ref="id47"/>
            <label kind="guard" x="-187" y="-119">!hExe &amp;&amp; fail &amp;&amp;
actionTimer&gt;=
processingTime</label>
            <label kind="synchronisation" x="-187" y="-68">stop_r_action!</label>
            <label kind="assignment" x="-187" y="-51">actionTimer=0</label>
            <nail x="-195" y="-127"/>
        </transition>
        <transition>
            <source ref="id44"/>
            <target ref="id46"/>
            <label kind="synchronisation" x="-476" y="68">pass_out?</label>
            <nail x="-510" y="85"/>
        </transition>
        <transition>
            <source ref="id44"/>
            <target ref="id46"/>
            <label kind="synchronisation" x="-476" y="85">dead_battery?</label>
            <nail x="-510" y="85"/>
        </transition>
        <transition>
            <source ref="id44"/>
            <target ref="id45"/>
            <label kind="guard" x="-425" y="-102">actionTimer&gt;=timerInterval</label>
            <label kind="assignment" x="-425" y="-85">actionTimer = 0,
changeDirection(),
checkSuccess()</label>
            <nail x="-527" y="-68"/>
            <nail x="-433" y="-68"/>
        </transition>
        <transition>
            <source ref="id45"/>
            <target ref="id44"/>
            <label kind="guard" x="-671" y="-178">hExe &amp;&amp; !success &amp;&amp; !fail
&amp;&amp; actionTimer
&gt;=processingTime</label>
            <label kind="assignment" x="-663" y="-127">actionTimer=0</label>
            <nail x="-552" y="-127"/>
        </transition>
    </template>
    <system>// Robot Instances
#RINSTANCES#

// Human Instances
#HINSTANCES#

// Controller Instances
o = Orchestrator(#NHUMSTOSERVE#);

system
#RSYSTEM#
#HSYSTEM#
o
;
    </system>
	<queries>
	</queries>
</nta>
